# --- Helper Function for Recalculating Projections ---
recalculate_projections <- function(app_state, auto_triggered = FALSE) {
  
  print(paste("Running recalculate_projections function", ifelse(auto_triggered, "(auto-triggered)", "")))
  
  # --- Gather all necessary info from state ---
  assumptions <- get_assumptions_data(app_state)
  base_rev <- get_base_revenue(app_state)
  noa <- get_non_operating_assets(app_state)
  
  # --- Robust parameter access ---
  params_list <- NULL
  if (!is.null(app_state$dcf$parameters) && is.reactivevalues(app_state$dcf$parameters)) {
    params_list <- tryCatch({ reactiveValuesToList(app_state$dcf$parameters) }, error = function(e) {print(paste("Warning: Error converting dcf$parameters to list:", e$message)); list( risk_free_rate = app_state$dcf$parameters$risk_free_rate, equity_premium = app_state$dcf$parameters$equity_premium, beta = app_state$dcf$parameters$beta, country_premium = app_state$dcf$parameters$country_premium, long_run_inflation = app_state$dcf$parameters$long_run_inflation, additional_terminal_growth = app_state$dcf$parameters$additional_terminal_growth, CAP = app_state$dcf$parameters$CAP, market_cap = app_state$dcf$parameters$market_cap ) })
  } else if (is.list(app_state$dcf$parameters)) { print("Warning: app_state$dcf$parameters is a regular list."); params_list <- app_state$dcf$parameters } else { print("Error: app_state$dcf$parameters is NULL or invalid type."); set_projections_data(app_state, NULL); return() }
  # --- End Robust parameter access ---
  
  # --- Debugging prints ---
  print(paste("Base revenue:", base_rev))
  print(paste("NOA:", noa))
  if (!is.null(params_list)) { print(paste("Discount rate inputs(%):", params_list$risk_free_rate %||% 'NA', params_list$equity_premium %||% 'NA', params_list$beta %||% 'NA', params_list$country_premium %||% 'NA')); print(paste("Terminal growth inputs(%):", params_list$long_run_inflation %||% 'NA', params_list$additional_terminal_growth %||% 'NA')); print(paste("CAP:", params_list$CAP %||% 'NA')) } else { print("Parameters list is NULL.") }
  # --- End Debugging prints ---
  
  
  # --- Initial Input Validation ---
  valid <- TRUE
  if (is.null(assumptions) || !"Assumption" %in% colnames(assumptions) || ncol(assumptions) <= 1) { print("Validation failed: assumptions invalid."); valid <- FALSE }
  if (is.null(base_rev) || !is.numeric(base_rev)) { print("Validation failed: base_rev invalid."); valid <- FALSE }
  if (is.null(noa) || !is.numeric(noa) || noa < 0) { print("Validation failed: noa invalid."); valid <- FALSE }
  if (is.null(params_list)) { print("Validation failed: params_list is NULL."); valid <- FALSE }
  if (valid && (is.null(params_list$CAP) || !is.numeric(params_list$CAP) || params_list$CAP <= 0)) { print("Validation failed: CAP invalid."); valid <- FALSE }
  
  # --- Rate Parameter Input Validation ---
  required_rate_params <- c("risk_free_rate", "equity_premium", "beta", "country_premium", "long_run_inflation", "additional_terminal_growth")
  if (valid) { # Only check if params_list is not NULL
    missing_params <- setdiff(required_rate_params, names(params_list))
    non_numeric_params <- required_rate_params[sapply(required_rate_params, function(p) { val <- params_list[[p]]; is.null(val) || !is.numeric(val) || is.na(val) })]
    if (length(missing_params) > 0 || length(non_numeric_params) > 0) {
      print("Validation failed: Missing or non-numeric rate parameters.")
      print(paste(" Missing:", paste(missing_params, collapse=", "))); print(paste(" Non-numeric/Null:", paste(non_numeric_params, collapse=", ")))
      valid <- FALSE
    }
  }
  
  # --- Exit if any validation failed ---
  if (!valid) {
    print("Exiting recalculate_projections due to validation failure.")
    set_projections_data(app_state, NULL)
    return()
  }
  # --- End Validation Checks ---
  
  # --- Calculate Rates ---
  params_list$discount_rate <- calculate_discount_rate(params_list)
  params_list$terminal_growth_rate <- calculate_terminal_growth_rate(params_list)
  # --- End Calculate Rates ---
  
  # --- ADD PRINT BEFORE CALL ---
  print("recalculate_projections: Final params_list before calling calculate_dcf_projections:")
  print(str(params_list)) # Print structure to see names and types
  # --- END ADD ---
  
  # --- Print final list before call ---
  print("recalculate_projections: Final params_list before calling calculate_dcf_projections:")
  print(str(params_list))
  # --- End Print ---
  
  # --- Call Core Calculation ---
  proj_result <- tryCatch({
    print("Calling calculate_dcf_projections FROM recalculate_projections...")
    calculate_dcf_projections( 
      assumptions_df = assumptions,
      base_revenue = base_rev,
      non_op_assets = noa,
      dcf_params = params_list,
      std_data = get_standardized_data(app_state)
    )
    # --- END MODIFICATION ---
  }, error = function(e) { print(paste("Error during projection calculation:", e$message)); showNotification(paste("Projection Calc Error:", e$message), type = "error", duration = 10); NULL })
  # --- End Call Core Calculation ---
  
  # --- Update State ---
  if (!is.null(proj_result)) { print("DCF projections calculation successful (or returned non-NULL)"); if (auto_triggered) { showNotification("Projections automatically updated", type = "message") } } else { print("DCF projections calculation failed or returned NULL") }
  set_projections_data(app_state, proj_result)
  # --- End Update State ---
} # End recalculate_projections

# --- Helper Function for Recalculating HURDLE DCF Projections ---
recalculate_hurdle_projections <- function(app_state, auto_triggered = FALSE) {
  
  print(paste("Running recalculate_HURDLE_projections function", ifelse(auto_triggered, "(auto-triggered)", "")))
  
  # --- Gather Hurdle Inputs ---
  hurdle_assumptions <- get_hurdle_assumptions_data(app_state)
  hurdle_base_rev <- get_hurdle_base_revenue(app_state)
  hurdle_noa <- get_hurdle_non_operating_assets(app_state)
  hurdle_params_list <- NULL
  if (!is.null(app_state$hurdle_dcf$parameters) && is.reactivevalues(app_state$hurdle_dcf$parameters)) {
    hurdle_params_list <- tryCatch(reactiveValuesToList(app_state$hurdle_dcf$parameters), error=function(e) NULL)
  }
  hurdle_inputs <- get_hurdle_inputs(app_state)
  
  # --- Basic Validation ---
  if (is.null(hurdle_assumptions) || !"Assumption" %in% colnames(hurdle_assumptions) || ncol(hurdle_assumptions) <= 1 ||
      is.null(hurdle_base_rev) || !is.numeric(hurdle_base_rev) ||
      is.null(hurdle_noa) || !is.numeric(hurdle_noa) || hurdle_noa < 0 ||
      is.null(hurdle_params_list) || is.null(hurdle_params_list$CAP) || !is.numeric(hurdle_params_list$CAP) || hurdle_params_list$CAP <= 0 ||
      is.null(hurdle_inputs)) {
    print("Cannot calculate HURDLE projections: Missing or invalid base inputs (incl. last_hist_year).")
    set_hurdle_projections_data(app_state, NULL)
    return()
  }
  
  # --- Parameter Validation (Rates) ---
  required_rate_params_hurdle <- c("risk_free_rate", "equity_premium", "beta", "country_premium",
                                   "long_run_inflation", "additional_terminal_growth")
  missing_hurdle <- setdiff(required_rate_params_hurdle, names(hurdle_params_list))
  non_numeric_hurdle <- required_rate_params_hurdle[sapply(required_rate_params_hurdle, function(p) { val <- hurdle_params_list[[p]]; is.null(val) || !is.numeric(val) || is.na(val) })]
  if (length(missing_hurdle) > 0 || length(non_numeric_hurdle) > 0) {
    print("Cannot calculate HURDLE projections: Missing or non-numeric DCF parameters for rate calc.")
    set_hurdle_projections_data(app_state, NULL)
    return()
  }
  
  # --- Calculate Rates ---
  hurdle_params_list$discount_rate <- calculate_discount_rate(hurdle_params_list)
  hurdle_params_list$terminal_growth_rate <- calculate_terminal_growth_rate(hurdle_params_list)
  
  # --- Call Core DCF Calculation ---
  hurdle_proj_result_raw <- tryCatch({
    print("Calling calculate_dcf_projections for HURDLE...")
    calculate_dcf_projections(
      assumptions_df = hurdle_assumptions,
      base_revenue = hurdle_base_rev,
      non_op_assets = hurdle_noa,
      dcf_params = hurdle_params_list, # Pass hurdle specific params
      std_data = get_standardized_data(app_state) # Pass standardized data
    )
  }, error = function(e) {
    print(paste("Error during HURDLE projection calculation:", e$message))
    showNotification(paste("Hurdle Calc Error:", e$message), type = "error", duration = 10)
    NULL
  })
  
  # --- Post-Process for Hurdle Target ---
  if (!is.null(hurdle_proj_result_raw)) {
    print("Post-processing Hurdle Projections...")
    hurdle_intrinsic_value_row <- hurdle_proj_result_raw[hurdle_proj_result_raw$Metric == "Intrinsic Value", ]
    
    # Check if intrinsic value was calculated
    if (nrow(hurdle_intrinsic_value_row) > 0) {
      # Get the first year column name
      first_year_col <- colnames(hurdle_proj_result_raw)[grepl("^\\d{4}$", colnames(hurdle_proj_result_raw))][1]
      hurdle_intrinsic_value <- hurdle_intrinsic_value_row[[first_year_col]]
      
      target_future_value <- hurdle_params_list$market_cap # We stored the target here
      
      hurdle_return_multiple <- NA # Default
      if (!is.null(target_future_value) && target_future_value > 0 && is.numeric(hurdle_intrinsic_value)) {
        hurdle_return_multiple <- hurdle_intrinsic_value / target_future_value
      }
      print(paste("Hurdle Intrinsic Value:", hurdle_intrinsic_value))
      print(paste("Hurdle Target Value:", target_future_value))
      print(paste("Hurdle Achieved Multiple:", hurdle_return_multiple))
      
      # Update the "Proportion of Market Cap" row
      prop_row_idx <- which(hurdle_proj_result_raw$Metric == "Proportion of Market Cap")
      if (length(prop_row_idx) > 0) {
        hurdle_proj_result_raw$Metric[prop_row_idx] <- "Hurdle Multiple Achieved (x)" # Rename row
        # Clear existing values in that row
        hurdle_proj_result_raw[prop_row_idx, -1] <- NA
        # Place the calculated multiple in the first year column
        hurdle_proj_result_raw[prop_row_idx, first_year_col] <- hurdle_return_multiple
      } else {
        # Add the row if it doesn't exist
        new_row <- data.frame(Metric = "Hurdle Multiple Achieved (x)")
        new_row[1, setdiff(colnames(hurdle_proj_result_raw), "Metric")] <- NA
        new_row[1, first_year_col] <- hurdle_return_multiple
        hurdle_proj_result_raw <- rbind(hurdle_proj_result_raw, new_row)
      }
    } else {
      print("Hurdle Intrinsic Value not found in projections.")
    }
    
    
    # Update state
    set_hurdle_projections_data(app_state, hurdle_proj_result_raw)
    
    if (auto_triggered) {
      showNotification("Hurdle projections automatically updated", type = "message")
    }
  } else {
    # Set hurdle projections to NULL if calculation failed
    set_hurdle_projections_data(app_state, NULL)
  }
}